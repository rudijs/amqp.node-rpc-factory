'use strict';

var should = require('chai').should(),
  amqp = require('amqplib'),
  q = require('q'),
  sinon = require('sinon');

var env = process.env,
  rpcPublisherFactory = require('../lib/rpc-publisher-factory');

describe('RPC Client', function () {

  if (env.TEST_QUIET) {
    sinon.stub(console, 'info', function () {
    });
    sinon.stub(console, 'warn', function () {
    });
  }

  // Setup shared variables used in the tests below

  // The correlation ID generated by the publish method, sent to the consumer then returned by the consumer so the publisher can verify with it
  // Need to store it during the test so the test can verify with it
  var correlationId;

  // The expected sent and reply strings
  var messageSent = 'Publish a Test Message';
  var messageReply = 'Publish a Test Message-OK';

  // The reply-to queue the publisher will send to the consumer
  var uniqueAmqpPrivateReplyQueue = 'a45sdf6-7r98w-adf79s-65io4u';

  var assertQueueThenStub = {
    then: function (callback) {
      return callback();
    }
  };

  afterEach(function (done) {
    if (amqp.connect.restore) {
      amqp.connect.restore();
    }
    done();
  });

  it('should handle connection failure', function (done) {

    sinon.stub(amqp, 'connect', function () {
      var deferred = q.defer();
      deferred.reject(new Error('Stubbed amqp.connect()'));
      return deferred.promise;
    });

    var publisher = rpcPublisherFactory.create();

    publisher.publish('publish a message')
      .catch(function publishError(err) {
        should.exist.err;
        err.status.should.equal(503);
        err.message.should.equal('Service Unavailable');
      })
      .then(done, done);

  });

  it('should send a message and receive a reply', function (done) {

    var channelStub = {
      assertQueue: function () {
        return {
          then: function (callback) {
            callback({queue: uniqueAmqpPrivateReplyQueue});
            return assertQueueThenStub;
          }
        };
      },

      consume: function (queue, callback, options) {
        queue.should.equal(uniqueAmqpPrivateReplyQueue);
        (typeof callback).should.equal('function');
        options.noAck.should.be.true;

        // This is the reply from the consumer
        // In this example we'll make it so the consumer simply appends 'OK' to the sent message and returns it
        // Use setImmediate so that the callback is run on the next tick of the event loop.
        setImmediate(function () {
          callback({
            content: new Buffer(messageSent + '-OK'),
            properties: {
              correlationId: correlationId
            }
          });
        });

      },

      sendToQueue: function (replyTo, content, options) {
        replyTo.should.equal('node_rpc_queue');
        content.toString().should.equal(messageSent);
        should.exist(options.expiration);
        should.exist(options.correlationId);
        options.replyTo.should.equal(uniqueAmqpPrivateReplyQueue);

        // Store the correlationID, used in the reply MaybeAnswer function
        correlationId = options.correlationId;
      }

    };

    var createChannelStub = {
      createChannel: function () {
        return {
          then: function (createChannelSuccess) {
            return createChannelSuccess(channelStub);
          }
        };
      },
      close: sinon.spy()
    };

    var connectStub = {
      then: function (getConnectionSuccess) {
        return getConnectionSuccess(createChannelStub);
      }
    };

    sinon.stub(amqp, 'connect').returns(connectStub);

    var publisher = rpcPublisherFactory.create({
      debugLevel: 2,
      standalone: true
    });

    publisher.publish(messageSent)
      .then(function publishSuccess(res) {
        should.exist.res;
        res.should.equal(messageReply);

        sinon.assert.calledOnce(createChannelStub.close);
      })
      .then(done, done);

  });

  it('should handle mismatched reply correctionId number', function (done) {

    var channelStub = {
      assertQueue: function () {
        return {
          then: function (callback) {
            callback({queue: uniqueAmqpPrivateReplyQueue});
            return assertQueueThenStub;
          }
        };
      },

      consume: function (queue, callback, options) {
        queue.should.equal(uniqueAmqpPrivateReplyQueue);
        (typeof callback).should.equal('function');
        options.noAck.should.be.true;

        // This is the reply from the consumer
        // In this example we'll make it so the consumer simply appends 'OK' to the sent message and returns it
        // Use setImmediate so that the callback is run on the next tick of the event loop.
        setImmediate(function () {
          callback({
            content: new Buffer(messageSent + '-OK'),
            properties: {
              correlationId: 'xxx-mismatched-correlationId-xxx'
            }
          });
        });
      },

      sendToQueue: function (replyTo, content, options) {
        replyTo.should.equal('node_rpc_queue');
        content.toString().should.equal(messageSent);
        options.replyTo.should.equal(uniqueAmqpPrivateReplyQueue);
      }

    };

    var createChannelStub = {
      createChannel: function () {
        return {
          then: function (createChannelSuccess) {
            return createChannelSuccess(channelStub);
          }
        };
      },
      close: sinon.spy()
    };

    var connectStub = {
      then: function (getConnectionSuccess) {
        return getConnectionSuccess(createChannelStub);
      }
    };

    sinon.stub(amqp, 'connect').returns(connectStub);

    var publisher = rpcPublisherFactory.create({
      debugLevel: 2,
      standalone: true
    });

    publisher.standalone.should.be.true;

    var spy = sinon.spy(publisher, 'logError');

    publisher.publish(messageSent)
      .catch(function publishError(err) {

        // test user response
        err.status.should.equal(503);
        err.message.should.equal('Service Unavailable');

        // test error logging
        sinon.assert.calledOnce(spy);
        sinon.assert.calledWithMatch(spy, /RPC\ replyTo\.correlationId\ mismatch/);

        sinon.assert.calledOnce(createChannelStub.close);

      })
      .then(done, done);

  });

  it('should timeout if no response after 3000ms and close channel in non-standalone mode', function (done) {

    var clock = sinon.useFakeTimers();

    var createChannelStub = {
      createChannel: function () {
        return {
          then: function (createChannelSuccess) {
            return createChannelSuccess(channelStub);
          }
        };
      },

      close: sinon.spy()
    };

    var connectStub = {
      then: function (getConnectionSuccess) {
        return getConnectionSuccess(createChannelStub);
      }
    };

    var channelStub = {
      assertQueue: function () {
        return {
          then: function (callback) {
            callback({queue: uniqueAmqpPrivateReplyQueue});
            return assertQueueThenStub;
          }
        };
      },

      consume: function (queue, callback, options) {
        queue.should.equal(uniqueAmqpPrivateReplyQueue);
        (typeof callback).should.equal('function');
        options.noAck.should.be.true;

        // Timeout the consume() wait for reply
        clock.tick(3001);

      },

      sendToQueue: function (replyTo, content, options) {
        replyTo.should.equal('node_rpc_queue');
        content.toString().should.equal(messageSent);
        options.replyTo.should.equal(uniqueAmqpPrivateReplyQueue);
      },

      close: sinon.spy()

    };

    sinon.stub(amqp, 'connect').returns(connectStub);

    var publisher = rpcPublisherFactory.create({
      debugLevel: 1
    });

    publisher.standalone.should.be.false;

    var spy = sinon.spy(publisher, 'logError');

    publisher.publish(messageSent)
      .catch(function publishError(err) {

        // test user response
        err.status.should.equal(503);
        err.message.should.equal('Service Unavailable');

        // test error logging
        sinon.assert.calledOnce(spy);
        sinon.assert.calledWithMatch(spy, /RPC\ Reply\ Timeout/);

        sinon.assert.calledOnce(channelStub.close);

        clock.restore();

      })
      .then(done, done);

  });

});
